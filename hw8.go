package main

import (
	"fmt"
)

//Домашнее задание 7
func main() {

	fmt.Println("========================")
	fmt.Println("Задача 08.01.")
	fmt.Println("========================")
	//task0801()
	fmt.Println("========================")
	fmt.Println("Задача 08.02.")
	fmt.Println("========================")
	//task0802()
	fmt.Println("========================")
	fmt.Println("Задача 08.03.")
	fmt.Println("========================")
	fmt.Println(task0803([]int{5, 5, 5, 10,20, 10}))

}
func task0801() {
	/*Задание 1:
	Пользователь вводит месяц, программа должна вывести, на какое время года (зима, весна, лето, осень) этот месяц выпадает.

	Как группировать:
	декабрь, январь, февраль - зима
	март, апрель, май - весна
	июнь, июль, август - лето
	сентябрь, октябрь, ноябрь - осень*/

	fmt.Println("Времена года")
	fmt.Print("Введите месяц:")
	var val string //месяц
	fmt.Scan(&val)
	switch val {
	case "декабрь", "январь", "февраль":
		fmt.Println("зима")
	case "март", "апрель", "май":
		fmt.Println("весна")
	case "июнь", "июль", "август":
		fmt.Println("лето")
	case "сентябрь", "октябрь", "ноябрь":
		fmt.Println("осень")
	default:
		fmt.Println("Ошибка ввода")
	}

}
func task0802() {
	/*Задание 2:
	Пользователь вводит будний день недели в сокращенной форме(пн, вт, ср, чт, пт) и получает развернутый список всех последующих рабочих дней, включая пятницу.
	Пример:
	пользователь вводит:
	вт
	программа дает ответ:
	вторник
	среда
	четверг
	пятница	*/
	fmt.Println("Сколько осталось рабочих дней")
	fmt.Print("Введите день недели:")
	var val string //день недели
	fmt.Scan(&val)
	switch val {
	case "пн":
		fmt.Println("понедельник")
		fallthrough
	case "вт":
		fmt.Println("вторник")
		fallthrough
	case "ср":
		fmt.Println("среда")
		fallthrough
	case "чт":
		fmt.Println("четверг")
		fallthrough
	case "пт":
		fmt.Println("пятница")
	default:
		fmt.Println("Ошибка ввода")
	}

}
func task0803(bills []int) bool {
	/*Задание 3*:
	В киоске с лимонадом, каждый лимонад стоит 5 долларов.
	Клиенты стоят в очереди, чтобы купить у вас, и заказывают по одному (в порядке, указанном в счетах).
	Каждый покупатель может купить только один лимонад и заплатить купюрой на 5, 10 или 20 долларов. Вы должны дать каждому покупателю сдачу с его купюры.

	Обратите внимание, что сначала у вас нет сдачи.

	Подсказка:
	Верните true, в том случае, если вы можете предоставить каждому покупателю правильную сдачу.
	Сигнатура функции lemonadeChange(bills []int) bool
	где bills - это купюры, которые мы получаем от покупателей, по 1й купюре от каждого

	Примеры:

	Пример 1:
	Ввод: [5,5,5,10,20]
	Вывод: true
	Пояснение:
	От первых 3 клиентов мы собираем три купюры по 5 долларов по порядку.
	От четвертого покупателя мы получаем купюру на 10 долларов и возвращаем 5 долларов сдачи.
	От пятого клиента мы получаем 20 долларов и возвращаем купюры на 10 и 5 долларов.
	Поскольку все клиенты получили правильную сдачу, мы выводим true.


	Пример 2:

	Ввод: [10,10]
	Вывод: false

	Пример 3:
	Ввод: [5,5,10,10,20]
	Вывод: false

	Пояснение:
	От первых двух клиентов по порядку мы получаем две купюры по 5 долларов.
	Для следующих двух клиентов мы собираем купюры по 10 долларов и возвращаем 5 долларов 3му и 4му клиенту.
	Последнему покупателю мы не можем вернуть сдачу в размере 15 долларов, потому что у нас есть только две купюры по 10 долларов.
	Поскольку не все покупатели получили правильную сдачу, ответ false.*/
	
	
	fmt.Println("Продажа лимонада", bills)
	result := true //Результат выполнения 
	cost := 5 // стоимость лимонада
	for ibill, bill := range bills {
		change := bill - cost // размер сдачи
		if change > 0 {
			for i := 0; ibill > i && change > 0; i++ {
				if bills[i] <= change {
					change = change - bills[i]
					bills[i] = 0
				}
			}
			if change > 0 {
				result = false
				break
			}
		}

	}
	return result
}

