package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("========================")
	fmt.Println("Задача 09.01.")
	fmt.Println("========================")
	task0901()
	fmt.Println("========================")
	fmt.Println("Задача 09.02.")
	fmt.Println("========================")
	task0902()
}
func task0901() {
	/*

			1 задание:
			Что нужно сделать
			В данном модуле мы с вами рассмотрели примеры по целочисленным типам, их размерам в памяти и что происходит при ее переполнении.
			Теперь давайте напишем программу, которая будет в цикле с использованием встроенных констант
			(на предельные значения целых чисел, в пакете math)
			подсчитывать сколько приходится переполнений чисел типа uint8, uint16 в диапазоне от 0 до uint32.

			Что оценивается

		    Проверить, что для нахождения количества переменных используется цикл.
		    Проверить, что при выполнении задачи используются встроенные в пакет math константы на максимальные значения типов.
		    Подсчитать количество переполнений типов uint8, uint16 в диапазоне от 0 до uint32.
	*/

	countUint8 := -1
	countUint16 := -1
	for i := 0; i < math.MaxUint32; i = i + int(math.MaxUint8) + 1 {
		if uint8(i) == 0 {
			countUint8++
			if uint16(i) == 0 {
				countUint16++
			}
		}
	}
	fmt.Printf("Количество Uint8: %v \nКоличество Uint16: %v\n", countUint8, countUint16)
}
func task0902() {
	/*
			2 задание:
			Что нужно сделать
			Достаточно часто, при передаче по сети или сохранении больших объемов данных, приходится выбирать тип с минимальным размером в памяти,
			чтобы экономить трафик или место на диске. Напишите программу, в которую пользователь вводит 2 числа (int16),
			а программа выводит в какой минимальный тип данных можно сохранить результат умножения этих чисел.

			Советы и рекомендации
			Обратите внимание, что положительный результат, можно сохранить в меньшем типе, за счет использования uint8, uint16.
			Чтобы не возникло проблем с переполнением в процессе умножения, числа считываем в int16, а перед умножением их лучше привести в int32

			Что оценивается
			Проверить на примерах:
		    1 1 результат uint8
		    1 -1 результат int8
		    640 100 результат uint16
		    -640 100 результат int32
		    3000 3000 результат uint32
		    -3000 3000 результат int32
	*/
	var number1, number2 int16 //Пользовательский ввод
	var resultType string      //Описание тапа результата
	fmt.Print("Введите первое число:")
	fmt.Scan(&number1)
	fmt.Print("Введите второе число:")
	fmt.Scan(&number2)
	result := int32(number1) * int32(number2)
	if result >= 0 {
		switch {
		case result < math.MaxUint8:
			resultType = "Uint8"
		case result < math.MaxUint16:
			resultType = "Uint16"
		case uint(result) < math.MaxUint32:
			resultType = "Uint32"
		default:
			resultType = "Ошибка"
		}
	} else {
		switch {
		case result > -math.MaxInt8:
			resultType = "Int8"
		case result > -math.MaxInt16:
			resultType = "Int16"
		case int(result) > -int(math.MaxInt32):
			resultType = "Int32"
		default:
			resultType = "Ошибка"
		}
	}
	fmt.Println(number1, "*", number2, "=", result, "Тип:", resultType)

}
